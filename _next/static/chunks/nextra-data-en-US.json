{"/FAQs":{"title":"FAQs","data":{"":"Question: Wen launch?\nAnswer: 8th of October for the whitelist participants, 24 hours later - public launch. UTC (Coordinated Universal Time): 12:30 PM the minting will be enabled.\nQuestion: How to mint?\nAnswer: Go to https://traitforge.game website, connect your wallet and start minting either with a single mint (one transaction mints one NFT) or a batch mint (one transaction with a set amount of ETH mints multiple NFTs). For testnet, having some Ethereum Sepolia on the Base blockchain is needed. For the mainnet launch, you will be able to mint with Ethereum on Base (if you don't have ETH on Base chain (L1 ETH is not supported!), bridging will be necessary).\nQuestion: How much time do whitelist participants have to mint their NFTs?\nAnswer: 24 hours when minting is enabled. After that time everybody will be able to mint.","gameplaystrategytokenomics#Gameplay/Strategy/Tokenomics":"Question: What is TraitForge?\nAnswer: TraitForge is an NFT breeding and nuking game that combines strategy with value-accrual. Players can mint, forge, sell, or nuke NFT entities to gain rewards from the Nuke Fund, a central pool of ETH on the Base chain.\nQuestion: How does breeding work in TraitForge?\nAnswer: Breeding (or forging) is performed by combining two NFT entities (a \"Merger\" and a \"Forger\"). This produces a new generation entity that inherits traits from both parents.\nQuestion: What is the Nuke Fund?\nAnswer: The Nuke Fund is a pool of ETH collected from mint fees and in-game activities primarily through minting which transfers 85% of each mint to the Nuke Fund. Players can nuke (burn) their NFT to claim a share of the fund. The percentage of the fund claimable depends on the NFT's Nuke Factor, which increases as it ages.\nQuestion: What are \"Forger\" and \"Merger\" roles?\nAnswer: Entities are either \"Forgers\" or \"Mergers.\" Forgers are required to breed new entities, and Mergers pay fees to forge with them. The roles are assigned during the initial mint, with a 2:1 bias towards Mergers.\nQuestion: How does the ageing process work?\nAnswer: NFT entities age over time, determined by their Performance Factor. Faster-ageing entities reach maturity in about 30 days, while slower ones can take up to 600 days. Full maturity means a maximum Nuke Factor of 50%, making them highly valuable for nuking or forging.\nQuestion: What is the \"Golden God\"?\nAnswer: The Golden God is a special NFT entity with perfect parameters, giving it a significant edge over other entities if played correctly. It’s a unique entity designed to be highly sought-after.\nQuestion: What is the economic model of TraitForge?\nAnswer: The game involves minting, forging, and nuking to generate ETH for the Nuke Fund. Mint fees, forge fees, and sales fees feed into this fund. Players earn from forging new entities or claiming rewards from the Nuke Fund.\nQuestion: What happens if I \"nuke\" my NFT entity?\nAnswer: Nuking means permanently burning your NFT to claim a share of the ETH from the Nuke Fund. The amount you can claim depends on the entity's Nuke Factor, which can reach a maximum of 50%.\nQuestion: What happens to the game if the Nuke Fund runs out?\nAnswer: The Nuke Fund is designed to be sustainable by limiting any single entity's claim to a maximum of 50%. If activities like minting, forging, or sales decline, the DAO participants can adjust game parameters to keep the fund active and maintain player engagement.\nQuestion: What platforms will TraitForge launch on?\nAnswer: TraitForge will first launch on the Base L2 chain and then be ported to Solana later.\nQuestion: What are the main strategies in TraitForge?\nAnswer: Players can adopt different strategies like holding entities to age them, forging until infertility, selling from mint, or nuking to win. Each strategy has different risks and rewards based on game progression and Nuke Fund growth.\nQuestion: What is the minting structure for TraitForge?\nAnswer: TraitForge has 10 generations of entities, each containing 10,000 NFTs. The minting starts at 0.005 ETH, with prices increasing linearly by 0.0000245 ETH. For example, Gen 1 reaches a final mint price of 0.25 ETH, while Gen 2 ends at 0.30 ETH. Mint revenue is distributed 90% to the Nuke Fund and 10% to the Dev Fund.\nQuestion: How does the ageing mechanism affect entities in TraitForge?\nAnswer: Entities age based on their Performance Factor, which ranges from 1 to 9. Entities with a higher Performance Factor mature faster, with the maximum Performance Factor resulting in full maturity in about 30 days. Entities with the lowest Performance Factor take up to 730 days to reach full maturity.\nQuestion: How does the Forge Potential of an entity work?\nAnswer: Forge Potential determines the number of times an entity can forge before becoming infertile. Every time an entity forges, a point is deducted from its Forge Potential. After a year, the Forge Potential resets to its original value.\nQuestion: What visual progression do TraitForge entities go through?\nAnswer: TraitForge features a generational visual evolution where entities progress from human-like to cyborgs, and eventually into full machines. This adds a compelling visual narrative that distinguishes each generation from the previous one.\nQuestion: What determines an entity’s share of the Nuke Fund?\nAnswer: The Nuke Factor represents an entity’s claim to the Nuke Fund. Upon minting, entities receive a Nuke Factor between 1% and 10%, which can increase to a maximum of 50% through gameplay and ageing.\nQuestion: What are the roles of \"Forger\" and \"Merger\" in TraitForge?\nAnswer: Entities are either \"Forgers\" or \"Mergers.\" Forgers can list themselves for a fee to forge with a Merger. Mergers pay the fee to create new entities. Roles are assigned during the initial mint, with a 1:2 ratio of Forgers to Mergers.","trait-token-airdrop#$TRAIT Token Airdrop":"Question: How does the TRAIT airdrop work?\nAnswer: The TRAIT token airdrop distributes 55% of the total 1 billion supply to players based on Player Total Entropy (PTE). This reflects player contributions and ownership. Other allocations include 15% for the Dev Fund, 5% for KOLs/Partners, 15% for referrals, and 10% for market liquidity.\nQuestion: What are the conditions for the TRAIT airdrop?\nAnswer: Before the airdrop, developers can withdraw from the Dev Fund to cover costs. After the airdrop is triggered, a 30-day period accumulates rewards, preventing developer withdrawals. Once ended, 10% of $TRAIT is added to Uniswap as liquidity, and LP tokens are locked for public trading.\nQuestion: What is Player Total Entropy (PTE)?\nAnswer: PTE is the accumulated entropy value of all NFTs owned by a player. It determines their share in the airdrop allocation, reflecting their engagement and contributions to the game.\nQuestion: How are liquidity and token stability ensured after the airdrop?\nAnswer: After the 30-day accumulation period, the game will add liquidity to Uniswap using the collected ETH and 10% of the TRAIT to be publicly traded."}},"/Game-Strategy/active-trading-and-market-strategy":{"title":"Active Trading and Market Strategy","data":{"":"For those captivated by the economic and social dynamics of TraitForge, active trading and strategic market influence emerge as compelling strategies. Players in this realm actively engage in buying, selling, and trading entities, leveraging market trends and strategically selling entities based on these trends. Tailored for the economically savvy and patient, this play style appeals to players who thrive in speculation and the intricacies of market dynamics as integral elements of the gameplay experience."}},"/Game-Strategy/mint-and-nuke":{"title":"Mint and Nuke","data":{"":"Players who prefer a quicker, more direct approach might opt for the \"Mint and Nuke\" strategy. This involves minting Gen 1 entities(NFTs) and waiting for the minimum maturity period before nuking them to claim a share of the Nuke Fund. This strategy is akin to a short-term investment, hoping to capitalize on the initial investment quickly. It suits players looking for immediate returns rather than engaging in the complexities of forging or trading."}},"/Game-Strategy/strategic-long-term-forging":{"title":"Strategic Long-Term Forging","data":{"":"This strategy entices players into TraitForge’s depth with a focus on selecting entities for forging to optimize traits, performance, and nuke values, enhancing lineage value over time. It combines patience and strategic planning, requiring entities to mature and forging decisions that foresee future generations’ potential. Beyond  forging, it involves calculated choices to develop a dominating lineage within the game’s ecosystem. Players engage with the community for suitable partners, manage costs, and adapt to the evolving landscape. Ideal for those seeking a challenge and a long-term commitment, this approach offers a rewarding journey, significantly influencing TraitForge’s direction and creating powerful entities that reshape gameplay."}},"/Game-Strategy/the-long-game-aging-and-maximizing-nuke-value":{"title":"The Long Game Aging and Maximizing Nuke Value","data":{"":"Players who are in it for the long haul might adopt a strategy focused on aging their entities to maximize their nuke value. By waiting until an entity reaches full maturity, they can nuke it for a substantial portion of the Nuke Fund. This strategy requires patience and a calculated risk assessment, as holding onto an entity for too long could mean missing out on optimal nuke opportunities. It suits players who are less interested in the breeding aspects and more in maximizing returns from the nuke mechanism."}},"/GamePlay/entropy":{"title":"Entropy","data":{"":"The traits per Entity are derived from “Entropy” a 6-digit random number associated with each Entity. The entropy is established at the genesis of the game and cannot be changed. Role is either “Forger” or “Merger”, with a 2:1 bias towards Mergers. Forge Potential dictates how many times an Entity can forge before becoming infertile till reset (10% of the population is infertile (0 Forge Potential). Performance Factor dictates how quickly an Entity matures. Initial Nuke Factor dictates the starting Nuke Factor for each Entity.","entropy-123456#entropy: 123456":"Entropy[1] = varOptions1\nEntropy[2] = varOptions2\nEntropy[3] = varOptions3 && colorOptions3\nEntropy[4] = varOptions4 && colorOptions4\nEntropy[5] = colorOptions5 && color2\nEntropy[6] = colorOptions6 && color1\nEntropy /40 = initalNukeFactor\nEntropy % 10 = performanceFactor\nEntropy % 3 ? 0 == Role\nEntropy is set into uint256 slots, with each slot able to contain a 78 digit number - or 13 concatenated entropies. Thus 770 slots are needed to contain 10,000 entropies. Genesis entropies are seeded using blockhash. Setting all 770 uint256 slots cost 15m gas, and due to contract & block size limits, this cannot be set in contract initialisation. Instead a function writes in entropy in 3 passes after the contract is deployed and remain immutable after this.There is a certain entropy, “999999” which is referred to as “the Golden God”, since it has perfect parameters and will exceed all other entities if played correctly. The Golden God is scanned for and is kept out of the first 2 passes, but is deliberately set in the final pass (at some random point). The Golden God should be the most valuable entity. A function is built to read entropy for each entity, as well as convert to entity traits at any point in time. The Golden God entropies' position changes every generation.","code-and-functions#Code and Functions":"","function-writebatchentropys#Function writeBatchEntropy's":"Functions writeEntropyBatch1, writeEntropyBatch2, and writeEntropyBatch3 entropy values are initialized in three stages to manage gas costs. Each stage, handled by the batches populates portions of the entropySlots array with pseudo-random values. Batch 1 initializes the first 256 slots, Batch 2 the next 256, and Batch 3 the remaining slots up to 770. For each index, a pseudo-random value is generated using the formula:(uint256(keccak256(abi.encodePacked(block.number, i)))mod10 78)These values are then stored in the entropySlots array, ensuring none are equal to 999999. This method, updating the lastInitializedIndex after each batch, distributes the gas costs over multiple transactions to save on gas fee's.\nfunction writeEntropyBatch1() public {\n    require(lastInitializedIndex < batchSize1, 'Batch 1 already initialized.');\n    uint256 endIndex = lastInitializedIndex + batchSize1; // calculate the end index for the batch\n    unchecked {\n      for (uint256 i = lastInitializedIndex; i < endIndex; i++) {\n        uint256 pseudoRandomValue = uint256(\n          keccak256(abi.encodePacked(block.number, i))\n        ) % uint256(10) ** 78; // generate a  pseudo-random value using block number and index\n        require(pseudoRandomValue != 999999, 'Invalid value, retry.');\n        entropySlots[i] = pseudoRandomValue; // store the value in the slots array\n      }\n    }\n    lastInitializedIndex = endIndex;\n  }\n  // second batch initialization\n  function writeEntropyBatch2() public {\n    require(\n      lastInitializedIndex >= batchSize1 && lastInitializedIndex < batchSize2,\n      'Batch 2 not ready or already initialized.'\n    );\n    uint256 endIndex = lastInitializedIndex + batchSize1;\n    unchecked {\n      for (uint256 i = lastInitializedIndex; i < endIndex; i++) {\n        uint256 pseudoRandomValue = uint256(\n          keccak256(abi.encodePacked(block.number, i))\n        ) % uint256(10) ** 78;\n        require(pseudoRandomValue != 999999, 'Invalid value, retry.');\n        entropySlots[i] = pseudoRandomValue;\n      }\n    }\n    lastInitializedIndex = endIndex;\n  }\n  // allows setting a specific entropy slot with a value\n  function writeEntropyBatch3() public {\n    require(\n      lastInitializedIndex >= batchSize2 && lastInitializedIndex < maxSlotIndex,\n      'Batch 3 not ready or already completed.'\n    );\n    unchecked {\n      for (uint256 i = lastInitializedIndex; i < maxSlotIndex; i++) {\n        uint256 pseudoRandomValue = uint256(\n          keccak256(abi.encodePacked(block.number, i))\n        ) % uint256(10) ** 78;\n        entropySlots[i] = pseudoRandomValue;\n      }\n    }\n    lastInitializedIndex = maxSlotIndex;\n  }","function-initializealphaindices-and-getentropy#Function \"initializeAlphaIndices\" and \"getEntropy\"":"The specific entropy value 999999 is placed randomly to add an element of unpredictability. This is achieved through the initializeAlphaIndices function, which determines random selection points for the slot index and number index where 999999 will be placed. The function generates a hash using the block hash of the previous block and the current block's timestamp. This hash value is then used to calculate the slotIndexSelectionPoint and numberIndexSelectionPoint. The slot index is derived as( ( % 258) + 512), ensuring it falls within the higher range of the array, while the number index is simply  % 13. This ensures that each time the function is called, a new and unpredictable position is selected for placing the 999999 entropy value.\nfunction getEntropy(\n    uint256 slotIndex,\n    uint256 numberIndex\n  ) private view returns (uint256) {\n    require(slotIndex <= maxSlotIndex, 'Slot index out of bounds.');\n    if (\n      slotIndex == slotIndexSelectionPoint &&\n      numberIndex == numberIndexSelectionPoint\n    ) {\n      return 999999;\n    }\n    uint256 position = numberIndex * 6; // calculate the position for slicing the entropy value\n    require(position <= 72, 'Position calculation error');\n    uint256 slotValue = entropySlots[slotIndex]; // slice the required [art of the entropy value\n    uint256 entropy = (slotValue / (10 ** (72 - position))) % 1000000; // adjust the entropy value based on the number of digits\n    uint256 paddedEntropy = entropy * (10 ** (6 - numberOfDigits(entropy)));\n    return paddedEntropy; // return the caculated entropy value\n  }\nfunction initializeAlphaIndices() public onlyOwner {\n    uint256 hashValue = uint256(\n      keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))\n    );\n    uint256 slotIndexSelection = (hashValue % 258) + 512;\n    uint256 numberIndexSelection = hashValue % 13;\n    slotIndexSelectionPoint = slotIndexSelection;\n    numberIndexSelectionPoint = numberIndexSelection;\n  }","write-entropy-batches#Write Entropy Batches":"The writeBatchEntropy function initializes a series of pseudo-random values in the entropySlots array, which are later used for generating smaller entropy values. To minimize gas costs, it processes these values in batches, using the keccak256 hash function combined with block data (block number, timestamp) to generate each entropy value. The function updates the lastInitializedIndex after each batch, allowing subsequent transactions to continue where the previous one left off, and is restricted to the contract owner for secure control over the entropy initialization process.\nfunction writeEntropyBatch() public onlyOwner {\n        uint256 endIndex = 833; // We want to initialize all 770 slots\n        for (uint256 i = lastInitializedIndex; i < endIndex; i++) {\n            uint256 pseudoRandomValue = uint256(\n                keccak256(abi.encodePacked(block.number, block.timestamp, i))\n            ) % uint256(10) ** 77; // generate a pseudo-random value using block number and index\n            entropySlots[i] = pseudoRandomValue; // store the value in the slots array\n        }\n        lastInitializedIndex = endIndex; // Update the index to indicate initialization is complete\n    }","function-initializealphaindices#Function initializeAlphaIndices":"The initializeAlphaIndices function sets specific indices within the entropy array for generating special entropy values. Restricted to the contract owner, it generates two indices: slotIndexSelectionPoint and numberIndexSelectionPoint. These indices are computed using a hash derived from the previous block hash and the current block timestamp, ensuring pseudo-randomness. The slotIndexSelectionPointdesignates a specific slot in the array, while the numberIndexSelectionPoint specifies an index within that slot, enabling the contract to produce unique entropy values for other contracts.\nfunction initializeAlphaIndices() public onlyOwner {\n    uint256 hashValue = uint256(\n      keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))\n    );\n    uint256 slotIndexSelection = (hashValue % 258) + 512;\n    uint256 numberIndexSelection = hashValue % 13;\n    slotIndexSelectionPoint = slotIndexSelection;\n    numberIndexSelectionPoint = numberIndexSelection;\n  }","function-getentropy#Function getEntropy":"The getEntropy function calculates an entropy value based on a given slot and number index. It first verifies that the provided slot index is within bounds. If the slot and number indices match the predefined selection points, a special value of 999999 is returned. Otherwise, it computes the position for slicing the entropy value from the selected slot in the entropySlots array. The entropy value is then derived by extracting and adjusting a portion of the slot value, ensuring it fits within a specific digit range. This function returns the adjusted entropy value, which is used for generating pseudo-random values in the contract.\nfunction getEntropy(\n    uint256 slotIndex,\n    uint256 numberIndex\n  ) private view returns (uint256) {\n    require(slotIndex <= maxSlotIndex, 'Slot index out of bounds.');\n    if (\n      slotIndex == slotIndexSelectionPoint &&\n      numberIndex == numberIndexSelectionPoint\n    ) {\n      return 999999;\n    }\n    uint256 position = numberIndex * 6; // calculate the position for slicing the entropy value\n    require(position <= 72, 'Position calculation error');\n    uint256 slotValue = entropySlots[slotIndex]; // slice the required [art of the entropy value\n    uint256 entropy = (slotValue / (10 ** (72 - position))) % 1000000; // adjust the entropy value based on the number of digits\n    uint256 paddedEntropy = entropy * (10 ** (6 - numberOfDigits(entropy)));\n    return paddedEntropy; // return the caculated entropy value\n  }"}},"/GamePlay/aging":{"title":"Aging","data":{"":"The ageing mechanic is a vital game mechanic for the TraitForge ecosystem, boosting the PVP aspect of TraitForge. Aging provides a core gameplay mechanic for the influence of the value of TraitForge Entities, creating a broader playstyle for players to engage with.","aging-mechanic-of-entities#Aging Mechanic of Entities":"Every Entity ages by blocktime from their mint date, at a speed proportional to their Performance Factor (determined by entropy).\nThe fastest should mature fully after 30 days, with the slowest taking almost 2 years. Full maturity simply means their Nuke Factor is computed to be the maximum of 50%.\nMature Entities would be extremely lucrative to forge with or nuke, as they would be able to claim 50% of the Nuke Fund.","code-and-functions#Code and Functions":"","1-function-gettokencreationtimestampuint256-tokenid#1. Function getTokenCreationTimestamp(uint256 tokenId)":"This function retrieves the creation timestamp of an Entity based on its tokenId. It ensures the entity exists by checking if it has an owner. If the token doesn't exist, it reverts with an error. This timestamp is essential for calculating the age of the Entity and other time-dependent attributes.\nfunction getTokenCreationTimestamp(\n    uint256 tokenId\n  ) public view returns (uint256) {\n    require(\n      ownerOf(tokenId) != address(0),\n      'ERC721: query for nonexistent token'\n    );\n    return tokenCreationTimestamps[tokenId];\n  }","2-function-gettokenageuint256-tokenid#2. Function getTokenAge(uint256 tokenId)":"Calculates and returns the age of an NFT in seconds format. This function uses the creation timestamp obtained from getTokenCreationTimestamp and subtracts it from the current block timestamp (block.timestamp). It also checks that the token exists before performing the calculation.\n function getTokenAge(uint256 tokenId) public view returns (uint256) {\n    require(\n      ownerOf(tokenId) != address(0),\n      'ERC721: query for nonexistent token'\n    );\n    return block.timestamp - tokenCreationTimestamps[tokenId];\n  }","3-function-calculateage#3. Function calculateAge":"The calculateAge function computes the age of an entity by ensuring it exists. It calculates the number of days since the token's creation and adjusts this based on a performance factor derived from the entities entropy. The age is calculated by converting the adjusted days into years. This function combines the actual elapsed time since the entity's creation with an element influenced by the entity's unique properties, returning the age as an integer value in years.\nfunction calculateAge(uint256 tokenId) public view returns (uint256) {\n    require(nftContract.ownerOf(tokenId) != address(0), 'Token does not exist');\n    uint256 daysOld = (block.timestamp -\n      nftContract.getTokenCreationTimestamp(tokenId)) /\n      60 /\n      60 /\n      24;\n    uint256 perfomanceFactor = nftContract.getTokenEntropy(tokenId) % 10;\n    uint256 age = (daysOld *\n      perfomanceFactor *\n      MAX_DENOMINATOR *\n      ageMultiplier) / 365; // add 5 digits for decimals\n    return age;\n  }"}},"/GamePlay/economic-activity":{"title":"Economic Activity","data":{"introduction#Introduction":"TraitForges economic system is complex and functions heavily on player activity and community engagement. To enhance the PVP experience, 100% of all mint fees go into the Nuke Fund. 10% of every transaction e.g. (Forge Fees/Sales and mint fees) are then distributed from the Nuke Fund into the Dev fund or Dao Fund, depending on if the airdrop has started. Users can choose to pay the list fees of the Forgers to mint Gen 2+ entity's, or mint directly, and pay the Nuke Fund. In this way, Forgers capture 90% of the “mint potential” of their offspring, and will be incentivised to forge instead of Nuke. This means each Entity retains value all the time, since their on-market value is a reflection of their monetary potential.As gameplay increases and the Nuke Fund rises, Entities should accumulate constant value until they die or are nuked. The value of a Merger, whilst they have to pay-to-play, is a reflection of their potential offspring as well, since they acquire the Gen 2+ entity, not the Forger. Furthermore entities can be listed on a marketplace to be sold for a custom set ETH fee by the owner.","contract-breakdown#Contract Breakdown":"Economic activity can be broken down across these contracts: EntityForging, EntityTrading, NukeFund, Airdrop, DevFund and TraitForgeNft.","entity-creation-and-sales-traitforgenft-contract#Entity Creation and Sales (TraitForgeNft Contract)":"Minting Entities: Users can mint entities at a price that increases with each mint within the current generation. This creates an economic incentive to mint earlier in each generation cycle.\nRevenue Distribution: Minting fees are collected and part of these fees may be distributed to the NukeFund based on certain conditions, facilitating a transfer of funds into a broader economic pool managed by the NukeFund.","forging-entityforging-contract#Forging (EntityForging Contract)":"Listing for Forging: Owners of entities can list their entities for forging if they meet certain entropy-derived conditions. Listing involves setting a fee that merger owners must pay to forge with the listed entity.\nForging Transactions: When a breeding transaction occurs, the forging fee is divided between the NukeFund (10% as a development fee) and the entity owner (90%).","entitytrading#EntityTrading":"Entity Listing and Sale: Allows entity owners to list tokens for sale, ensuring ownership and contract approval, and transfers entities to the contract upon listing.\nBuying Entities: Facilitates purchasing listed entities by verifying the payment amount, transferring a portion to the NukeFund, and delivering the entity to the buyer.\nNukeFund Contributions: Automatically directs 10% of each sale to the NukeFund, with the ability for the contract owner to set the NukeFund address.","fund-management-nukefund-contract#Fund Management (NukeFund Contract)":"Fund Accumulation: The fund accumulates ETH through various channels, including direct payments and portions of fees from forging and trading.\nDeveloper and DAO Payments: A portion of the funds received (e.g., 10% of incoming payments) is distributed to either the developers addresses or a DAO, depending on certain conditions such as whether an airdrop has started.\nNuking Entities: Entity owners can \"nuke\" their entities, a process where an entity is burned in exchange for a payout from the fund, based on the tokens age and its entropy-derived \"nuke factor\". This mechanism provides a sink for tokens and an incentive for users to hold entities longer.","airdrops-and-additional-mechanics-airdrop-contract#Airdrops and Additional Mechanics (Airdrop contract)":"Airdrop Initiatives: Linked airdrop contracts can influence the behavior of other operations, such as whether additional amounts are added or subtracted during certain actions (e.g., during entity burns in the minting process).\nIncentives and User Engagement: By introducing mechanics like airdrops and nuking, the system encourages continued user engagement and investment in the ecosystem, driving both speculative and participatory economic activity.","devfund-contract#DevFund Contract":"Reward Accumulation and Distribution:\nThe contract collects funds through its receive function and automatically calculates rewards to distribute among registered developers.\nThe reward per developer is calculated based on the total incoming funds divided by the number of registered developers (totalDevCount). This means that as more funds are received, the rewards are evenly distributed among all registered developers."}},"/GamePlay/dao-fund":{"title":"DAO Fund","data":{"":"The DAOFund is a decentralized finance (DeFi) mechanism designed to autonomously manage a pool of assets. It leverages the Uniswap V2 protocol to facilitate automated trading, liquidity provision, and token management.","contracts-involved#Contracts Involved":"DAOfund: uses the IUniswapV2Router02 interface for interacting with the Uniswap protocol and an additional token interface ($Trait token). Also includes a fallback function to receive ETH directly. Upon receiving ETH, it automatically swaps the ETH for tokens on Uniswap, then burns those tokens. This could be part of a strategy to manage the fund's value or influence the token's supply.\nIDAOfund: Defines an interface for a fund managed by a DAO. This interface includes functions for depositing and withdrawing tokens, claiming rewards, and checking pending rewards. It also includes events that log these actions, which are essential for transparency and tracking within a blockchain environment.\nIUniswapV2Router01/IUniswayV2RRouter: Extends IUniswapV2Router01 by adding support for fee-on-transfer tokens (tokens that take a fee upon transfer and thus have different transfer and return amounts). It includes advanced swapping functions that handle these fee adjustments.","dao-functionality#DAO Functionality":"","1-automated-token-swapping#1. Automated Token Swapping:":"The fund automatically swaps incoming Ether (ETH) for a specified ERC-20 token using Uniswap’s liquidity pools. This operation is triggered when ETH is sent directly to the funds contract, ensuring immediate and automated response to contributions.","2-interfacing-with-uniswap#2. Interfacing with Uniswap:":"DAOFund interacts with both basic and advanced features of the Uniswap V2 router. It supports transactions with fee-on-transfer tokens, adding a layer of complexity and utility by managing tokens that change in quantity upon transfers.","3-simplifying-user-transactions#3. Simplifying User Transactions:":"Users can interact with the DAOFund without needing direct involvement in the complexities of token swaps or liquidity management. Contributions in ETH are automatically handled by the contract, simplifying the investment process."}},"/GamePlay/nuke-fund":{"title":"Nuke Fund","data":{"":"The Nuke Fund is a contract that accumulates ETH from new mints and economic activity, it handles economic transactions related to the fund, and receives and distributes Ethereum (ETH) based on interactions with entities.","key-features#Key Features":"Fund Accumulation: The contract collects ETH through a fallback function and allocates portions to different stakeholders based on predefined rules. The main fund grows as transactions such as minting, trading and forging occur, with a portion of incoming funds being distributed off to the DevFund or the DAO, depending on the state of the airdrop and other conditions.\nEntity Nuking: Entity holders can \"nuke\" their entities, which involves calculating a \"nuke factor\" based on the entities age and entropy. This factor determines how much of the fund the entity holder can claim. The claim is limited to prevent any single entity from draining too much of the fund.\nEconomic Incentive and Entity Burn: The process provides economic incentives to players  by offering them a substantial return on their entity based on the nuke factor. After claiming their share, the entity is burnt, which permanently removes it from circulation.\nDynamic Fund Management: The contract ensures that claims are balanced against the total fund size, with a maximum cap on claims (50%) to maintain the fund's longevity and effectiveness.","predetermined-rules#Predetermined Rules":"","fund-contributions#Fund Contributions:":"Whenever ETH is sent to the contract (via its fallback function), a portion is automatically allocated to different stakeholders based on the following rules:\n10% Developer Share: Of the total ETH received, 10% is earmarked for the DevFund.\nRemaining 90%: This portion is added to the main fund (Nuke fund) which is used for the nuking payouts.","dev-share-distribution#Dev Share Distribution:":"The distribution of the 10% developer share depends on whether the airdrop has started and whether DAO fund contributions are allowed:\nIf the airdrop has not started, the developer's share is transferred directly to the developer's address.\nIf the airdrop has started but DAO funds are not allowed, the share is sent to the contract owner.\nIf the airdrop has started and DAO funds are allowed, the share is sent to the DAO address.","entity-nuking#Entity Nuking:":"Entity holders can claim a part of the fund by \"nuking\" their entity. The amount claimable depends on the \"nuke factor\" of the entity, which is calculated based on:\nEntropy of the Entity: A six digit entity attribute that contributes to calculating its nuke factor e.g (687697).\nAge of the Entity: The time since the entity was created, measured in days.\nThe nuke factor influences the proportion of the fund that can be claimed by the entity owner.","claim-limits#Claim Limits:":"The claim from nuking an entity cannot exceed 50% of the current fund balance, ensuring that the fund remains sustainable and no single claim depletes it excessively.","entity-burn#Entity Burn:":"After a claim is made to the nuke fund, the corresponding entity is burnt, which means it is permanently removed from circulation.","eligibility-for-nuking#Eligibility for Nuking:":"An entity must be at least three days old to be eligible for nuking. This rule prevents immediate claims after acquisition and encourages longer-term holding.","code-and-functions#Code and Functions":"There are 3 functions involved in the process of nuking an Entity, \"calculateAge, calculateNukeFactor, nuke\".","1-function-calculateage#1. Function calculateAge":"The function calculateAge determines the age of an Entity. It first ensures that the token exists by checking its ownership status. Then, it calculates the number of days since the entity's creation by using the current block timestamp and the token's creation timestamp. The age calculation is adjusted by a performance factor derived from the entity's entropy, and this adjusted age is further normalized to years by dividing by 365. The function returns this calculated age as an integer.\nfunction calculateAge(uint256 tokenId) public view returns (uint256) {\n    require(nftContract.ownerOf(tokenId) != address(0), 'Token does not exist');\n    uint256 daysOld = (block.timestamp -\n      nftContract.getTokenCreationTimestamp(tokenId)) /\n      60 /\n      60 /\n      24;\n    uint256 perfomanceFactor = nftContract.getTokenEntropy(tokenId) % 10;\n    uint256 age = (daysOld *\n      perfomanceFactor *\n      MAX_DENOMINATOR *\n      ageMultiplier) / 365; // add 5 digits for decimals\n    return age;\n  }","2-function-calculatenukefactor#2. Function calculateNukeFactor":"Calculates the nuke factor of an entity, which influences the claimable amount from the nuke fund. This function ensures the tokens existence, then uses its entropy and age to compute the nuke factor. It divides the tokens entropy by four for an initial value, and adds this to a scaled product of the entities age in days. This resultant nuke factor determines the portion of the fund an entity owner can claim, integrating both the entities unique attributes and its age into the calculation.\n  function calculateNukeFactor(uint256 tokenId) public view returns (uint256) {\n    require(\n      nftContract.ownerOf(tokenId) != address(0),\n      'ERC721: operator query for nonexistent token'\n    );\n    uint256 entropy = nftContract.getTokenEntropy(tokenId);\n    uint256 adjustedAge = calculateAge(tokenId);\n    uint256 initialNukeFactor = entropy / 40; // calcualte initalNukeFactor based on entropy, 5 digits\n    uint256 finalNukeFactor = ((adjustedAge * defaultNukeFactorIncrease) /\n      MAX_DENOMINATOR) + initialNukeFactor;\n    return finalNukeFactor;\n  }","3-function-receive#3. Function receive":"The receive function handles incoming ETH transactions by first calculating and setting aside a 10% developer share of the received amount. The remainder is added to the fund's balance. Depending on the status of the airdrop contract, the developer share is either transferred directly to the developer's address, to the contract owner (if DAO funding isn't allowed), or to the DAO address. The function then logs the transaction with the sender and amount details, and updates the overall fund balance. This systematic distribution and logging ensure transparency and proper allocation of funds based on the contract's operational state.\nreceive() external payable {\n    uint256 devShare = msg.value / taxCut; // Calculate developer's share (10%)\n    uint256 remainingFund = msg.value - devShare; // Calculate remaining funds to add to the fund\n    fund += remainingFund; // Update the fund balance\n    if (!airdropContract.airdropStarted()) {\n      (bool success, ) = devAddress.call{ value: devShare }('');\n      require(success, 'ETH send failed');\n      emit DevShareDistributed(devShare);\n    } else if (!airdropContract.daoFundAllowed()) {\n      (bool success, ) = payable(owner()).call{ value: devShare }('');\n      require(success, 'ETH send failed');\n    } else {\n      (bool success, ) = daoAddress.call{ value: devShare }('');\n      require(success, 'ETH send failed');\n      emit DevShareDistributed(devShare);\n    }\n    emit FundReceived(msg.sender, msg.value); // Log the received funds\n    emit FundBalanceUpdated(fund); // Update the fund balance\n  }"}},"/GamePlay/generations-and-minting":{"title":"Generations and Minting","data":{"":"TraitForge has 10 generations, the inital mint upon game launch is gen1, this will increase as the game is played, to gens 2, 3 ect. Each generation holds a pre-determined array of 10,000 entities. The Mint fee for each generation is the same as Gen 1 (starting at 0.005 ETH, incrementing by 0.000245 ETH upto the 10,000th entity).Generation max mint price will increase as genreations progress, generations 1-4 are initaly set as seen below. Later generations are not currently set, as gens 1-4 will give feedback for game-play.\nFinal Entity Price \n Gen 1: 0.25 ETH\nGen 2: 0.30 ETH\nGen 3: 0.35 ETH\nGen 4: 0.4 ETH\nEach generation has a new \"TraitForger\" character image. This allows players to easily identify entity generations while providing a diverse visual experience to the gameplay. Generation count is increased upon the minting of an entity or the creation of new entities through forging.","code-and-functions#Code and Functions":"Generation Management Variables\nThese variables track the current generation number, the total circulation of tokens across all generations, and the count of tokens minted in each generation.\nuint256 public currentGeneration = 1;\nuint256 public totalGenerationCirculation = 0;\nmapping(uint256 => uint256) public generationMintCounts;\nFunction _incrementGeneration()\nThis function increments the generation number and resets the mint count for the new generation, ensuring the token cap per generation is enforced.\n  function _incrementGeneration() private {\n    require(\n      generationMintCounts[currentGeneration] >= maxTokensPerGen,\n      'Generation limit not yet reached'\n    );\n    currentGeneration++;\n    generationMintCounts[currentGeneration] = 0;\n    entropyGenerator.initializeAlphaIndices();\n    emit GenerationIncremented(currentGeneration);\n  }\nOther relevant generation advancement code can be found in \"forging\" and the \"_mintInternal\" functions. In the  \"forging\" function when a new entity is forged and created it is added to the circulation of the next generation.\nFunction \"_mintInternal\" has logic to increment the current generation upon a mint and track the entity count through generations.\n // Update generation and circulation\n    currentGeneration++;\n    totalGenerationCirculation++;\nfunction _mintInternal(address to, uint256 mintPrice) internal {\n    if (generationMintCounts[currentGeneration] >= MAX_TOKENS_PER_GEN) {\n      _incrementGeneration();\n    }"}},"/GamePlay/forging":{"title":"Forging","data":{"":"Forging involves the process of creating a new entity derived from the entropy of the two parent entities. Depending on your entity's role (\"forger/merger\"), players will have the in-game ability to forge their entities. The process of forging involves two separate entities. If an entity's ability to forge runs out (generation limit reached), then the next generation is minted with the genesis entropy off-by-one.","forging-process#Forging Process":"A forger lists itself with an ETH fee for the merger to pay.\nA merger entity interacts and pays the forger's set ETH fee.\nThe two parent entities' entropies are added together and then divided by 2 to create the offspring entity with a new entropy.\nThe new entity is minted, inherits a new entropy based on the parents' entropies, and is transferred to the merger's owner address.\nThe crucial parameters for an entity are “Nuke Factor”, “Forge Potential” and “Performance Factor”. These parameters are carried in an entity's entropy and are averaged upon forging. This will create a diverse forging marketplace with a mixture of high-low value entities for players to forge with.Important! Remember to consider the forger's traits before forging with them. Since parent parameters are averaged, forging with a lower value entity will produce a less valuable entity than your current one.","code-and-functions#Code and Functions":"","function-mintnewentity-forge-process#Function: mintNewEntity (forge process)":"The _mintNewEntity function mints a new entity based on the parents' entropies. It checks if the current generation has reached its minting limit and, if so, increments to the next generation. The forging process will reject if the child's generation is already full. A new token ID is generated and the entity is minted to the sender's address. This function sets the entity's entropy, generation, and updates mint counts. It also records the initial owner. If the airdrop hasn't started, it adjusts the sender's airdrop amount based on the entropy. Finally, it emits an event indicating a new entity has been minted, specifying the sender, token ID, entropy, and current generation before returning the new token ID.\nfunction _mintNewEntity(\n    uint256 entropy,\n    uint256 gen\n) private returns (uint256) {\n    require(\n        generationMintCounts[gen] < maxTokensPerGen,\n        'Exceeds maxTokensPerGen'\n    );\n    uint256 newTokenId = _tokenIds++;\n    _mint(msg.sender, newTokenId);\n    tokenEntropy[newTokenId] = entropy;\n    tokenGenerations[newTokenId] = gen;\n    generationMintCounts[gen]++;\n    initialOwners[newTokenId] = msg.sender;\n    if (\n        generationMintCounts[gen] >= maxTokensPerGen && gen == currentGeneration\n    ) {\n        _incrementGeneration();\n    }\n    if (!airdropContract.airdropStarted()) {\n        airdropContract.addUserAmount(msg.sender, entropy);\n    }\n    emit NewEntityMinted(msg.sender, newTokenId, entropy, gen);\n    return newTokenId;\n}","function-forge#Function Forge":"The forging function in facilitates the forging between two entities, identified by parent1Id and parent2Id, to create a new entity. The function delegates the forging process to the entityForgingContract using the funds provided (msg.value). It then ensures that the call to forging is authorized by verifying that the caller is the entityForgingContract. The function calculates the new entities entropy by averaging the entropy values of the two parent entities. A new entity is minted with this entropy, and the contract increments the current generation, updating the total number of entity's in circulation. Finally, the function emits an event documenting the forging and returns the new entities ID.\n function forge(\n    uint256 parent1Id,\n    uint256 parent2Id,\n    string memory\n  ) external whenNotPaused nonReentrant returns (uint256) {\n    require(\n      msg.sender == address(entityForgingContract),\n      'unauthorized caller'\n    );\n    uint256 newGeneration = getTokenGeneration(parent1Id) + 1;\n    /// Check new generation is not over maxGeneration\n    require(newGeneration <= maxGeneration, \"can't be over max generation\");\n    // Calculate the new entity's entropy\n    (uint256 forgerEntropy, uint256 mergerEntropy) = getEntropiesForTokens(\n      parent1Id,\n      parent2Id\n    );\n    uint256 newEntropy = (forgerEntropy + mergerEntropy) / 2;\n    // Mint the new entity\n    uint256 newTokenId = _mintNewEntity(newEntropy, newGeneration);\n    emit EntityForged(newTokenId, parent1Id, parent2Id, newEntropy);\n    return newTokenId;\n  }","function-listforforging#Function: listForForging":"Allows the owner of a forger entity to list it for forging by setting a fee. This ensures the caller owns the entity and resets the forging count if needed. It retrieves the entity's entropy to determine its forging potential and checks if the entity has reached its forging limit. The function also verifies if the entity is a forger, based on its entropy. If all conditions are met, the entity is listed for forging with the specified fee, and an event is emitted to signal that the entity is available for forging.\nfunction listForForging(\n    uint256 tokenId,\n    uint256 fee\n  ) public whenNotPaused nonReentrant {\n    require(!listings[tokenId].isListed, 'Token is already listed for forging');\n    require(\n      nftContract.ownerOf(tokenId) == msg.sender,\n      'Caller must own the token'\n    );\n    require(\n      fee >= minimumListFee,\n      'Fee should be higher than minimum listing fee'\n    );\n    _resetForgingCountIfNeeded(tokenId);\n    uint256 entropy = nftContract.getTokenEntropy(tokenId); // Retrieve entropy for tokenId\n    uint8 forgePotential = uint8((entropy / 10) % 10); // Extract the 5th digit from the entropy\n    require(\n      forgePotential > 0 && forgingCounts[tokenId] <= forgePotential,\n      'Entity has reached its forging limit'\n    );\n    bool isForger = (entropy % 3) == 0; // Determine if the token is a forger based on entropy\n    require(isForger, 'Only forgers can list for forging');\n    listings[tokenId] = Listing(msg.sender, tokenId, true, fee);\n    listedTokenIds[listingCount] = tokenId;\n    listingCount++;\n    emit ListedForForging(tokenId, fee);\n  }"}},"/TraitForger-Entity/forge-potential":{"title":"Forge Potential","data":{"":"Forge Potential is an entities ability to forge and create new entities with players. The [5] digit in an entity's entropy is it's ability to forge based off of entropy. Each entity may have the ability to forge 0-9 times depending on its Forge Potential.","can-you-gain-forge-potential#Can you gain forge Potential?":"An Entities Forge Potential is determined by the [5] digit in entropy, when forging, this number is tracked by a mapping tallying of current forges specific to tokenIds with their entropy.\nOnce an Entity has used all of its Forge Potential it will return an error \"ForgePotential limit reached, forge failed\" for example. This is effectively rendering the Entity infertile for a period of time.\nTo regain the lost Forge Potential a player must simply wait 1 year. The game has a timestamp from mint that will reset the mapping count back to the [5] digit entropy number once 1 year has been passed in blocks. The function resposible for this is \"_resetBreedingCountIfNeeded\".","entropy-123456#entropy: 123456":"Entropy[1] = varOptions1\nEntropy[2] = varOptions2\nEntropy[3] = varOptions3 && colorOptions3\nEntropy[4] = varOptions4 && colorOptions4\nEntropy[5] = colorOptions5 && color2\nEntropy[6] = colorOptions6 && color1\nEntropy /40 = initalNukeFactor\nEntropy % 10 = performanceFactor\nEntropy % 3 ? 0 == Role","how-does-mergepotential-affect-gameplay#How does mergePotential affect gameplay?":"Having a capped limit on forge potential allows for strategic gameplay. Encouraging players to forge their entities within a 1 year period to fully utilise their full potential. Allowing a reset of forge potential increases economic market flow and incentivises long term gameplay.","code-and-functions#Code and Functions":"","1-function-_resetforgingcountifneeded-entityforging-contract#1. Function _resetForgingCountIfNeeded (entityForging Contract)":"Function _resetForgingCountIfNeeded checks if a year has passed since the last forging count reset for an Entity and, if so, recalculates the count based on the Entities entropy. The new count, termed forge potential, is derived by scaling the entropy and using its modulus. The breeding count is then updated to this value, and the reset timestamp is set to the current time, ensuring the breeding settings reflect the Entity's unique characteristics annually.\n  function _resetForgingCountIfNeeded(uint256 tokenId) private {\n    uint256 oneYear = oneYearInDays;\n    if (lastForgeResetTimestamp[tokenId] == 0) {\n      lastForgeResetTimestamp[tokenId] = block.timestamp;\n    } else if (block.timestamp >= lastForgeResetTimestamp[tokenId] + oneYear) {\n      forgingCounts[tokenId] = 0; // Reset to the forge potential\n      lastForgeResetTimestamp[tokenId] = block.timestamp;\n    }\n  }","2-function-listforforging-entityforging-contract#2. Function listForForging (entityForging Contract)":"The function listForForging checks if an Entity qualifies as a \"forger\" based on its entropy. It uses the condition that the entropy modulo 3 must be zero for the Entity to be listed for forging. Additionally, it ensures the token is not already listed for forging, verifies the caller's ownership of the token, validates that the provided fee meets the minimum requirement, and resets the forging count if necessary. The function retrieves the token's entropy, calculates its forge potential, and ensures the token has not exceeded its forging limit. If all conditions are met, it increments the listing count, stores the listing information, and emits an event indicating the token has been listed for forging. If any of these checks fail, the operation is blocked with an error message such as \"Only forgers can list for forging.\"\n   function listForForging(\n    uint256 tokenId,\n    uint256 fee\n  ) public whenNotPaused nonReentrant {\n    Listing memory _listingInfo = listings[listedTokenIds[tokenId]];\n    require(!_listingInfo.isListed, 'Token is already listed for forging');\n    require(\n      nftContract.ownerOf(tokenId) == msg.sender,\n      'Caller must own the token'\n    );\n    require(\n      fee >= minimumListFee,\n      'Fee should be higher than minimum listing fee'\n    );\n    _resetForgingCountIfNeeded(tokenId);\n    uint256 entropy = nftContract.getTokenEntropy(tokenId); // Retrieve entropy for tokenId\n    uint8 forgePotential = uint8((entropy / 10) % 10); // Extract the 5th digit from the entropy\n    require(\n      forgePotential > 0 && forgingCounts[tokenId] <= forgePotential,\n      'Entity has reached its forging limit'\n    );\n    bool isForger = (entropy % 3) == 0; // Determine if the token is a forger based on entropy\n    require(isForger, 'Only forgers can list for forging');\n    ++listingCount;\n    listings[listingCount] = Listing(msg.sender, tokenId, true, fee);\n    listedTokenIds[tokenId] = listingCount;\n    emit ListedForForging(tokenId, fee);\n  }"}},"/GamePlay/trait-token-airdrop":{"title":"$TRAIT Token Airdrop","data":{"":"TraitForge will receive an airdrop of TRAIT tokens, which can be initiated at any time. Each instance of direct minting or forging to mint is recorded in the Airdrop Contract, along with the entropy of the minted entity. This process establishes a comprehensive tracking system for the total number of entities minted by each player and their corresponding entropy. In the event that a player 'nukes' an entity, the entropy allocated by that entity is removed. The cumulative entropy accrued by a player determines their final share of the airdrop. It is anticipated that the airdrop will be initiated within the first year of gameplay to facilitate a broader distribution of $TRAIT tokens.Up until the Airdrop is called, only Devs can withdraw Dev Fund dividends. This will pay for bootstrap dev costs.\nFor 30 days after the Airdrop is called, all DAO Fund rewards are accumulated and cannot be withdrawn by Devs. All ETH accumulated, as well as the 10% supply of TRAIT, is then deposited into a Uniswap liquidity pool, and the LP tokens are locked. Anyone can call this function, and as soon as it is called, the tokens are unlocked and available for trading.","airdrop-allocation-below#Airdrop allocation below:":"","trait-supply-1billion#$TRAIT supply 1Billion":"55% (550Million) Players\n15% (150Million) DevFund \n5% (50Million) kol’s/partners\n15% (150Million) Airdrop to referrals\n10% (100Million) Initial market liquidity","equations-for-airdrop#Equations for Airdrop":"","player-total-entropy-pte#Player Total Entropy (PTE):":"For each player, sum up the entropy values of all their NFTs. If a player has 5 NFTs, and each NFT has an entropy which is a six-digit number, their PTE would be the sum of these five entropy values.","total-entropy-te#Total Entropy (TE):":"This is the sum of all players’ PTEs.","players-token-allocation#Player’s Token Allocation:":"To find the number of tokens  that a player  receives from the airdrop."}},"/TraitForger-Entity/performance-factor":{"title":"Performance Factor","data":{"":"The \"performance factor\" is a numerical value that adjusts how the \"age\" of an entity is calculated. This factor is used to modify the standard calculation of time elapsed since the entities creation to reflect additional characteristics or behaviors encoded into the entity itself.PerformanceFactor is derived from the entropy of the token modulo 10. This means the performance factor can vary between 0 to 9.\nThis factor modulates the daysOld count, effectively altering the perceived age of the token. If the performance factor is higher, the token ages faster in terms of the age calculation.","example-of-entropy-use#Example of entropy use:":"","entropy-123456#entropy: 123456":"Entropy[1] = varOptions1\nEntropy[2] = varOptions2\nEntropy[3] = varOptions3 && colorOptions3\nEntropy[4] = varOptions4 && colorOptions4\nEntropy[5] = colorOptions5 && color2\nEntropy[6] = colorOptions6 && color1\nEntropy /40 = initalNukeFactor\nEntropy % 10 = performanceFactor\nEntropy % 3 ? 0 == Role","affect-on-gameplay#Affect on Gameplay":"Performance factor adds massive gameplay enchancements to TraitForge. It introduces uniqueness to entities, and acts as contributing factor to the value of entity.Performance factor allows for competitive scenarios involving PVP. Players lucky enough to mint a high performance factor entity will have faster access higher claim to the NukeFund. Where as lower performance factor holders will be forced to either take lower claims of the NukeFund, or play the long game.","code-and-functions#Code and Functions":"","1-function-calculateage#1. Function calculateAge":"Function calculateAge determines the age of an entity by calculating the days since its creation and adjusting this number with a performance factor derived from the entities entropy. It ensures the entity exists, computes the days old, scales this by the entropy-based performance factor, and converts the result from days to years. The age is then returned as an integer.\nfunction calculateAge(uint256 tokenId) public view returns (uint256) {\n    require(nftContract.ownerOf(tokenId) != address(0), 'Token does not exist');\n    uint256 daysOld = (block.timestamp -\n      nftContract.getTokenCreationTimestamp(tokenId)) /\n      60 /\n      60 /\n      24;\n    uint256 perfomanceFactor = nftContract.getTokenEntropy(tokenId) % 10;\n    uint256 age = (daysOld *\n      perfomanceFactor *\n      MAX_DENOMINATOR *\n      ageMultiplier) / 365; // add 5 digits for decimals\n    return age;\n  }"}},"/TraitForger-Entity/role":{"title":"Role","data":{"":"The roles of forger and merger are key to the evolving ecosytem of TraitForge. The two roles provide the game with the unique ability for entities to forge with each-other to create offspring entities. These offspring entities carry the averaged traits of it's parents.Entities generated in the initial mint are split by \"?modulus3 == 0\", creating a population 1/3 forgers and 2/3 mergers. Forgers can list themselves for a fee and Mergers pay the fee in order to mint the next generation Entity. Next generation Entities can be sold, forged again or nuked.\n### entropy: 123456\nEntropy[1] = varOptions1\nEntropy[2] = varOptions2\nEntropy[3] = varOptions3 && colorOptions3\nEntropy[4] = varOptions4 && colorOptions4\nEntropy[5] = colorOptions5 && color2\nEntropy[6] = colorOptions6 && color1\nEntropy /40 = initalNukeFactor\nEntropy % 10 = performanceFactor\nEntropy % 3 ? 0 == Role","functions-and-code#Functions and code":"","function-derivetokenparameters#Function deriveTokenParameters":"The role is determined by taking the modulus of the entropy with 3, resulting in a value of 0, 1, or 2. The boolean isForger is set to true if role equals 0, indicating that there is a one-third chance for isForger to be true. This logic directly influences whether the entity is considered a \"forger\" based on the derived role value.","function-listforforging#Function listForForging":"To determine if the token is a forger based on entropy.\nbool isForger = (entropy % 3) == 0; \n    require(isForger, 'Only forgers can list for forging');"}},"/TraitForger-Entity/traits":{"title":"Traits","data":{"":"TraitForge's goal is to bring real value to the NFT marketplace by providing players with incentives to play and interact. This is achieved through a competition, as players compete for a percentage claim to a \"Nuke Fund\" (ETH pool). Each TraitForge entity is provided with a set of parameters that represent the entity's functional value through its access to the \"Nuke Fund\".","these-traits-are#These Traits are:":"Nuke Factor\nForge Potential\nPerformance Factor\nRole\nEach of these traits provides unique gameplay factors that players will utilize to compete for the \"Nuke Fund\"."}},"/":{"title":"Introduction","data":{"":"Traitforge is a revolutionary NFT Nuke Fund game designed to bring value back to the NFT ecosystem by creating a competitive PVP community within the the game. Traitforge introduces \"Entities\", NFTs with programmatically generated art evolving through ten unique generations. Each generation features distinct physical traits and colors, coupled with randomly assigned parameters that allow claims to the nuke fund, forging, marketplace sales and gameplay enhancing features.Each generation holds 10,000 entities which are available for minting, with generations starting a low mint prices and linearly increasing as they progress through their generation and other generations. The Nuke Fund accumulates ETH from minting and economic activities, offering a unique mechanism where entities can be \"nuked\" to claim a share of the nuke fund. Unique parameters called \"traits\" will dictate the value of an entities claim to the nuke fund along with other core gameplay features.TraitForge is exclusive in its gameplay methods, giving players the ability to choose their preferred playstyle. Playstyles vary from fast paced minting to nuke, selling entities on the marketplace and forging to create new more powerful entities.\nTraitforge isn't just an NFT project; it's a pioneering venture that combines innovative gameplay mechanics with the potential for significant returns, setting a new standard in the NFT landscape."}},"/TraitForger-Entity/visuals":{"title":"Visuals","data":{"":"TraitForge has a unique visual Entity system. It consists of generational progression, colour variation through maturity and an array of parameters providing unique visual distinction between entity's.","generational-progression#Generational Progression":"TraitForge utilises a generational system to diversify the visuals of entities. There are 10 generations, the consensus is the first generation entity starts out as a human (gen 1). Slowly as the generations progress, the entities evolve from a human into a cyborg, ultimately ending up completely mechanical by generation 10.Slowly these changes will be visual to the players as they acquire higher generation entities. Note that the generation system only changes the visuals of an entity, the game mechanics stay the same.","color-and-maturity#Color and Maturity":"Color variation is a visual variable responsible for the identification of an entities value. The Entities finalNukeFactor is the variable responsible for the 'maturity/epicness' of the image.","physical-variables#Physical Variables":"Every entity generation has 4 sets of 10 physical variables.Each digit of the entropy string assigns values as follows: The first digit determines the option index for varOptions1 and is not used for color. The second digit selects the option index for varOptions2 and is also not used for color. The third digit sets the option index for varOptions3 and the color array index for colorOptions3. The fourth digit determines the option index for varOptions4 and the color array index for colorOptions4. The fifth digit specifies the color array index for colorOptions5 and the base color for color2. The sixth digit assigns the color array index for colorOptions6 and the base color for color1.\n### entropy: 123456\nEntropy[1] = varOptions1\nEntropy[2] = varOptions2\nEntropy[3] = varOptions3 && colorOptions3\nEntropy[4] = varOptions4 && colorOptions4\nEntropy[5] = colorOptions5 && color2\nEntropy[6] = colorOptions6 && color1\nEntropy /40 = initalNukeFactor\nEntropy % 10 = performanceFactor\nEntropy % 3 ? 0 == Role"}},"/TraitForger-Entity/nuke-factor":{"title":"Nuke Factor","data":{"":"Nuke Factor represents an entities stake in the Nuke Fund. Upon minting, an entity receives a Nuke Factor ranging from 1-25%, determined by its inherent entropy. Through engaging gameplay elements like aging and forging, this percentage can be elevated up to a maximum of 50%, which the the maximum claimable amount of the Nuke Fund. As the cornerstone of the TraitForge ecosystem, Nuke Factor fuels competition, with players striving to achieve the highest percentage NukeFactor entities.\nNukeFactor has two stages. These stages are used to define the initial value of the entities NukeFactor, and the final nuke factor percentage which is the claimable amount from the Nuke Fund.","initialnukefactor#Initialnukefactor:":"The initialNukeFactor is computed directly from the entropy of an entity.\n{initialNukeFactor} = {entropy}{40}","entropy-123456#entropy: 123456":"Entropy[1] = varOptions1\nEntropy[2] = varOptions2\nEntropy[3] = varOptions3 && colorOptions3\nEntropy[4] = varOptions4 && colorOptions4\nEntropy[5] = colorOptions5 && color2\nEntropy[6] = colorOptions6 && color1\nEntropy /40 = initalNukeFactor\nEntropy % 10 = performanceFactor\nEntropy % 3 ? 0 == Role","finalnukefactor#Finalnukefactor:":"The finalNukeFactor incorporates the initialNukeFactor and modifies it further by adding a component based on the age of the entity.\nAgeInDays is calculated separately and represents how long the token has been \"alive\" or active since its creation. The calculation ageInDays * 250 / 10000 effectively scales the age to have a proportionate impact on the NukeFactor (2.5% increase), ensuring that older entity's can have a potentially higher influence or value.\nfinalNukeFactor = ((adjustedAge * defaultNukeFactorIncrease) / 100000) + initialNukeFactor","code-and-functions#Code and Functions":"","function-calculatenukefactor#Function calculateNukeFactor":"Calculates the nuke factor of an entity, which influences the claimable amount from the nuke fund. The function checks the entity's existence, then uses its entropy and age to compute the \"finalNukeFactor\". It divides the entities entropy by fourty for an initial value, and adds this to a scaled product of the entity's age in days. This resultant nuke factor determines the portion of the fund an entity owner can claim, integrating both the entity's unique attributes and its age into the calculation.\nfunction calculateNukeFactor(uint256 tokenId) public view returns (uint256) {\n    require(\n      nftContract.ownerOf(tokenId) != address(0),\n      'ERC721: operator query for nonexistent token'\n    );\n    uint256 entropy = nftContract.getTokenEntropy(tokenId);\n    uint256 adjustedAge = calculateAge(tokenId);\n    uint256 initialNukeFactor = entropy / 40; // calcualte initalNukeFactor based on entropy\n    uint256 finalNukeFactor = ((adjustedAge * defaultNukeFactorIncrease) /\n      100000) + initialNukeFactor;\n    return finalNukeFactor;\n  }","function-nuke#Function nuke":"The nuke function allows the owner of an entity to claim a portion of the fund based on the entity's finalNukeFactor. First, it verifies that the caller owns the entity and that the entity is eligible to be nuked. The function calculates the entities finalNukeFactor using its entropy and age. The potential claim amount is determined by the finalNukeFactor, capped at 50% of the current fund size. The appropriate claim amount is then transferred to the entity owner, the fund balance is updated, and the entity is burned.\nfunction nuke(uint256 tokenId) public whenNotPaused nonReentrant {\n    require(\n      nftContract.isApprovedOrOwner(msg.sender, tokenId),\n      'ERC721: caller is not token owner or approved'\n    );\n    require(\n      nftContract.getApproved(tokenId) == address(this) ||\n        nftContract.isApprovedForAll(msg.sender, address(this)),\n      'Contract must be approved to transfer the NFT.'\n    );\n    require(canTokenBeNuked(tokenId), 'Token is not mature yet');\n    uint256 finalNukeFactor = calculateNukeFactor(tokenId); // finalNukeFactor has 5 digits\n    uint256 potentialClaimAmount = (fund * finalNukeFactor) / MAX_DENOMINATOR; // Calculate the potential claim amount based on the finalNukeFactor\n    uint256 maxAllowedClaimAmount = fund / maxAllowedClaimDivisor; // Define a maximum allowed claim amount as 50% of the current fund size\n    // Directly assign the value to claimAmount based on the condition, removing the redeclaration\n    uint256 claimAmount = finalNukeFactor > nukeFactorMaxParam\n      ? maxAllowedClaimAmount\n      : potentialClaimAmount;\n    fund -= claimAmount; // Deduct the claim amount from the fund\n    nftContract.burn(tokenId); // Burn the token\n    (bool success, ) = payable(msg.sender).call{ value: claimAmount }('');\n    require(success, 'Failed to send Ether');\n    emit Nuked(msg.sender, tokenId, claimAmount); // Emit the event with the actual claim amount\n    emit FundBalanceUpdated(fund); // Update the fund balance\n  }"}}}